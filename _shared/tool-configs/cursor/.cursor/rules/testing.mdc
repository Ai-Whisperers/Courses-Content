---
description: Testing patterns and best practices
globs: ["**/*.test.ts", "**/*.spec.ts", "**/test_*.py", "**/*_test.py"]
---

# Testing Rules

## Unit Tests

### Structure
```typescript
describe('ModuleName', () => {
  describe('functionName', () => {
    beforeEach(() => {
      // Reset state
    });

    it('should return X when given Y', () => {
      // Arrange
      const input = createTestData();

      // Act
      const result = functionUnderTest(input);

      // Assert
      expect(result).toBe(expected);
    });

    it('should throw Error when invalid input', () => {
      // Arrange
      const invalidInput = {};

      // Act & Assert
      expect(() => functionUnderTest(invalidInput))
        .toThrow(ValidationError);
    });
  });
});
```

### Best Practices
- One assertion concept per test
- Use factories for test data
- Clean up after tests
- Isolate tests from each other
- Mock external dependencies

## E2E Tests (Playwright)

### Page Object Model
```typescript
// pages/login.page.ts
export class LoginPage {
  constructor(private page: Page) {}

  // Locators - use data-testid
  private emailInput = this.page.locator('[data-testid="email"]');
  private passwordInput = this.page.locator('[data-testid="password"]');
  private submitButton = this.page.locator('[data-testid="submit"]');
  private errorAlert = this.page.locator('[data-testid="error"]');

  // Navigation
  async goto() {
    await this.page.goto('/login');
    await this.page.waitForLoadState('networkidle');
  }

  // Actions
  async login(email: string, password: string) {
    await this.emailInput.fill(email);
    await this.passwordInput.fill(password);
    await this.submitButton.click();
  }

  // Assertions
  async expectError(message: string) {
    await expect(this.errorAlert).toContainText(message);
  }

  async expectLoggedIn() {
    await expect(this.page).toHaveURL(/\/dashboard/);
  }
}
```

### Test Structure
```typescript
// tests/login.spec.ts
import { test, expect } from '@playwright/test';
import { LoginPage } from '../pages/login.page';

test.describe('Login', () => {
  let loginPage: LoginPage;

  test.beforeEach(async ({ page }) => {
    loginPage = new LoginPage(page);
    await loginPage.goto();
  });

  test('should login with valid credentials', async () => {
    await loginPage.login('user@test.com', 'password123');
    await loginPage.expectLoggedIn();
  });

  test('should show error with invalid credentials', async () => {
    await loginPage.login('user@test.com', 'wrong');
    await loginPage.expectError('Invalid credentials');
  });
});
```

### Best Practices
- Use stable selectors (data-testid)
- Wait for elements properly
- Isolate tests (no shared state)
- Use fixtures for test data
- Take screenshots on failure

## API Tests

### Structure
```typescript
describe('POST /api/users', () => {
  it('should create user with valid data', async () => {
    // Arrange
    const userData = {
      email: 'test@example.com',
      name: 'Test User'
    };

    // Act
    const response = await request(app)
      .post('/api/users')
      .send(userData);

    // Assert
    expect(response.status).toBe(201);
    expect(response.body.success).toBe(true);
    expect(response.body.data.email).toBe(userData.email);
  });

  it('should return 400 with invalid email', async () => {
    // Arrange
    const invalidData = {
      email: 'not-an-email',
      name: 'Test'
    };

    // Act
    const response = await request(app)
      .post('/api/users')
      .send(invalidData);

    // Assert
    expect(response.status).toBe(400);
    expect(response.body.success).toBe(false);
    expect(response.body.error.code).toBe('VALIDATION_ERROR');
  });
});
```

## Test Data Factories

```typescript
// factories/user.factory.ts
export function createTestUser(overrides?: Partial<User>): User {
  return {
    id: randomUUID(),
    email: `test-${Date.now()}@example.com`,
    name: 'Test User',
    createdAt: new Date(),
    ...overrides,
  };
}
```

## Mocking

```typescript
// Mock external service
jest.mock('../services/email.service');

const mockEmailService = EmailService as jest.Mocked<typeof EmailService>;

beforeEach(() => {
  mockEmailService.send.mockResolvedValue({ success: true });
});

it('should send welcome email', async () => {
  await userService.create({ email: 'test@example.com' });

  expect(mockEmailService.send).toHaveBeenCalledWith(
    expect.objectContaining({
      to: 'test@example.com',
      template: 'welcome'
    })
  );
});
```
